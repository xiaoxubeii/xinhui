<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CPET AT Replay (Offline)</title>
  <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 0; }
    header { padding: 12px 16px; background: #0b6cff; color: #fff; }
    main { padding: 12px 16px; }
    .row { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; margin-bottom: 12px; }
    label { font-size: 14px; display: inline-flex; align-items: center; gap: 8px; }
    input[type="text"] { width: 640px; max-width: 100%; }
    input[type="number"] { width: 120px; }
    select { min-width: 220px; }
    .panel { border: 1px solid #ddd; background: #fafafa; padding: 12px; }
    .status { font-size: 13px; color: #333; }
    .muted { color: #666; font-size: 12px; }
    .charts { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 12px; }
    @media (max-width: 1000px) {
      .charts { grid-template-columns: repeat(1, minmax(0, 1fr)); }
    }
    #prob-chart, #vo2-chart { min-height: 320px; }
    button { padding: 6px 12px; }
    code { background: #f2f2f2; padding: 2px 4px; border-radius: 3px; }
  </style>
</head>
<body>
  <header>
    <h2 style="margin:0;">AT Prob Replay (Offline)</h2>
  </header>
  <main>
    <div class="row">
      <label>Results Dir:
        <input id="results-dir" type="text" value="/home/cheng/workspace/cpetx_workspace/cpet_former/pace/v4/internal/20260126_023159/models/3/train/results/" />
      </label>
      <button id="scan-btn">Scan</button>
    </div>

    <div class="row">
      <label>Dataset:
        <select id="dataset-select"></select>
      </label>
      <label>Exam:
        <select id="exam-select"></select>
      </label>
    </div>

    <div class="row">
      <label>Threshold:
        <input id="threshold-input" type="number" step="0.01" min="0" max="1" value="0.8" />
      </label>
      <label>Persistence:
        <input id="persistence-input" type="number" step="1" min="1" value="2" />
      </label>
      <label>Step (ms):
        <input id="speed-input" type="number" step="10" min="10" value="300" />
      </label>
      <button id="play-btn">Play</button>
      <button id="pause-btn">Pause</button>
      <button id="step-btn">Step</button>
    </div>

    <div class="panel">
      <div class="status" id="status-text">Ready.</div>
      <div class="muted" id="summary-text"></div>
    </div>

    <div class="charts" style="margin-top:12px;">
      <div id="prob-chart"></div>
      <div id="vo2-chart"></div>
    </div>
  </main>

  <script>
    const API_BASE = "/api";
    const statusText = document.getElementById("status-text");
    const summaryText = document.getElementById("summary-text");
    const datasetSelect = document.getElementById("dataset-select");
    const examSelect = document.getElementById("exam-select");

    let sequenceList = [];
    let currentSequence = null;
    let playbackIndex = 0;
    let playbackTimer = null;
    let validSeries = null;
    let triggerInfo = null;
    let vo2Series = null;

    function setStatus(message) {
      statusText.textContent = message;
    }

    function setSummary(message) {
      summaryText.innerHTML = message;
    }

    function getSelection() {
      const resultsDir = document.getElementById("results-dir").value.trim();
      const selection = datasetSelect.value;
      if (!selection) {
        return null;
      }
      const [mode, split] = selection.split("::");
      return { resultsDir, mode, split };
    }

    function computeValidSeries(sequence) {
      const probs = sequence.probs || [];
      const mask = sequence.mask || [];
      const times = sequence.times || [];
      const phase = sequence.phase || [];
      const vTimes = [];
      const vProbs = [];
      const vPhase = [];
      for (let i = 0; i < probs.length; i += 1) {
        if (mask[i]) continue;
        vTimes.push(times[i] ?? i * sequence.default_step_sec);
        vProbs.push(probs[i]);
        vPhase.push(phase[i] ?? null);
      }
      return { times: vTimes, probs: vProbs, phase: vPhase };
    }

    function computeTrigger(series, threshold, persistence) {
      let count = 0;
      const triggers = [];
      for (let i = 0; i < series.probs.length; i += 1) {
        if (series.probs[i] >= threshold) {
          count += 1;
        } else {
          count = 0;
        }
        if (count >= persistence) {
          triggers.push(i);
        }
      }
      const firstTriggerIndex = triggers.length ? triggers[0] : null;
      return { triggers, firstTriggerIndex };
    }

    function computeVo2Series(sequence, series) {
      const pred = sequence.vo2_pred;
      if (!pred || !pred.length) {
        return null;
      }
      const phaseTimes = [];
      for (let i = 0; i < series.times.length; i += 1) {
        if (series.phase[i] === 1) {
          phaseTimes.push(series.times[i]);
        }
      }
      let vo2Times = null;
      if (phaseTimes.length === pred.length) {
        vo2Times = phaseTimes;
      } else if (sequence.times && sequence.times.length === pred.length) {
        vo2Times = sequence.times;
      } else {
        vo2Times = pred.map((_, idx) => idx * sequence.default_step_sec);
      }
      return { times: vo2Times, pred: pred };
    }

    function updateSummary() {
      if (!currentSequence || !validSeries) {
        setSummary("");
        return;
      }
      const tStar = currentSequence.t_star;
      const atPred = currentSequence.at_pred;
      const vo2PeakLabel = currentSequence.vo2_peak_label;
      const vo2AtPred = computeVo2AtPred();
      const centerLabel = currentSequence.center_name ?? currentSequence.center_id ?? "n/a";
      const parts = [
        `Examination ID: ${currentSequence.examination_id ?? "n/a"}`,
        `Center: ${centerLabel}`,
        `AT Time: ${tStar ?? "n/a"}`,
        `AT Pred: ${atPred ?? "n/a"}`,
        `VO2 Peak Pred at AT Time: ${vo2AtPred ?? "n/a"}`,
        `VO2 Peak: ${vo2PeakLabel ?? "n/a"}`
      ];
      setSummary(parts.join("<br />"));
    }

    function computeVo2AtPred() {
      if (!currentSequence || !vo2Series) return null;
      const tStar = currentSequence.t_star;
      if (tStar === null || tStar === undefined) return null;
      let bestIdx = null;
      let bestDiff = Infinity;
      for (let i = 0; i < vo2Series.times.length; i += 1) {
        const diff = Math.abs(vo2Series.times[i] - tStar);
        if (diff < bestDiff) {
          bestDiff = diff;
          bestIdx = i;
        }
      }
      if (bestIdx === null) return null;
      const value = vo2Series.pred[bestIdx];
      if (value === null || value === undefined) return null;
      return Number(value).toFixed(2);
    }

    function renderProbChart() {
      if (!currentSequence || !validSeries) return;
      const threshold = parseFloat(document.getElementById("threshold-input").value);
      const tStar = currentSequence.t_star;
      const triggerIdx = triggerInfo?.firstTriggerIndex ?? null;
      const triggerTime = triggerIdx !== null ? validSeries.times[triggerIdx] : null;
      const cursorTime = validSeries.times[playbackIndex] ?? null;

      const shapes = [];
      const xMin = Math.min(...validSeries.times);
      const xMax = Math.max(...validSeries.times);
      shapes.push({
        type: "line",
        x0: xMin,
        x1: xMax,
        y0: threshold,
        y1: threshold,
        line: { color: "rgba(255,0,0,0.4)", dash: "dash" }
      });
      if (tStar !== null && tStar !== undefined) {
        shapes.push({
          type: "line",
          x0: tStar,
          x1: tStar,
          y0: 0,
          y1: 1,
          xref: "x",
          yref: "paper",
          line: { color: "#0b6cff", dash: "dot" }
        });
      }
      if (triggerTime !== null) {
        shapes.push({
          type: "line",
          x0: triggerTime,
          x1: triggerTime,
          y0: 0,
          y1: 1,
          xref: "x",
          yref: "paper",
          line: { color: "rgba(0,150,0,0.8)", dash: "dash" }
        });
      }
      if (cursorTime !== null) {
        shapes.push({
          type: "line",
          x0: cursorTime,
          x1: cursorTime,
          y0: 0,
          y1: 1,
          xref: "x",
          yref: "paper",
          line: { color: "rgba(255,165,0,0.9)" }
        });
      }

      Plotly.newPlot("prob-chart", [
        {
          x: validSeries.times,
          y: validSeries.probs,
          mode: "lines+markers",
          name: "AT Prob",
          marker: { size: 5, color: "#1f77b4" }
        }
      ], {
        title: "AT Probability",
        xaxis: { title: "Time (s)" },
        yaxis: { title: "Prob", range: [0, 1] },
        shapes: shapes
      }, { displayModeBar: false });
    }

    function renderVo2Chart() {
      if (!currentSequence) return;
      if (!vo2Series) {
        Plotly.newPlot("vo2-chart", [], {
          title: "VO2 Peak (no data)",
          xaxis: { title: "Time (s)" },
          yaxis: { title: "VO2" }
        }, { displayModeBar: false });
        return;
      }
      const peakLabel = currentSequence.vo2_peak_label;
      const traces = [
        {
          x: vo2Series.times,
          y: vo2Series.pred,
          mode: "lines+markers",
          name: "VO2 Pred",
          marker: { size: 4, color: "#ff7f0e" }
        }
      ];
      if (peakLabel !== null && peakLabel !== undefined) {
        const line = vo2Series.times.map(() => peakLabel);
        traces.push({
          x: vo2Series.times,
          y: line,
          mode: "lines",
          name: "VO2 Peak Label",
          line: { color: "#2ca02c", dash: "dash" }
        });
      }
      Plotly.newPlot("vo2-chart", traces, {
        title: "VO2 Peak",
        xaxis: { title: "Time (s)" },
        yaxis: { title: "VO2" }
      }, { displayModeBar: false });
    }

    function applySettings() {
      if (!currentSequence) return;
      const threshold = parseFloat(document.getElementById("threshold-input").value);
      const persistence = parseInt(document.getElementById("persistence-input").value, 10);
      triggerInfo = computeTrigger(validSeries, threshold, persistence);
      playbackIndex = 0;
      renderProbChart();
      updateSummary();
    }

    function stepPlayback() {
      if (!validSeries) return;
      playbackIndex = Math.min(playbackIndex + 1, validSeries.times.length - 1);
      renderProbChart();
    }

    function startPlayback() {
      if (!validSeries) return;
      if (playbackTimer) return;
      const interval = parseInt(document.getElementById("speed-input").value, 10);
      playbackTimer = setInterval(() => {
        if (playbackIndex >= validSeries.times.length - 1) {
          stopPlayback();
          return;
        }
        playbackIndex += 1;
        renderProbChart();
      }, Math.max(interval, 10));
    }

    function stopPlayback() {
      if (playbackTimer) {
        clearInterval(playbackTimer);
        playbackTimer = null;
      }
    }

    async function scanDatasets() {
      const resultsDir = document.getElementById("results-dir").value.trim();
      if (!resultsDir) {
        setStatus("Please provide a results directory.");
        return;
      }
      setStatus("Scanning...");
      const res = await fetch(`${API_BASE}/replay/scan`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ results_dir: resultsDir })
      });
      if (!res.ok) {
        setStatus(`Scan failed: ${res.status}`);
        return;
      }
      const data = await res.json();
      datasetSelect.innerHTML = "";
      if (!data.length) {
        setStatus("No datasets found.");
        return;
      }
      const readyItems = data.filter(item => item.ready);
      readyItems.forEach((item, idx) => {
        const opt = document.createElement("option");
        opt.value = `${item.mode}::${item.split}`;
        opt.textContent = `${item.mode}/${item.split}`;
        if (idx === 0) opt.selected = true;
        datasetSelect.appendChild(opt);
      });
      if (!readyItems.length) {
        setStatus("No ready datasets with probability outputs.");
        return;
      }
      setStatus(`Found ${readyItems.length} dataset(s).`);
      await loadSequenceList();
    }

    async function loadSequenceList() {
      const selection = getSelection();
      if (!selection) return;
      const res = await fetch(`${API_BASE}/replay/list`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          results_dir: selection.resultsDir,
          split: selection.split,
          mode: selection.mode
        })
      });
      if (!res.ok) {
        setStatus(`List failed: ${res.status}`);
        return;
      }
      const data = await res.json();
      sequenceList = data.sequences || [];
      examSelect.innerHTML = "";
      sequenceList.forEach((item, idx) => {
        const opt = document.createElement("option");
        opt.value = item.examination_id;
        opt.textContent = `${item.examination_id} (len=${item.length})`;
        if (idx === 0) opt.selected = true;
        examSelect.appendChild(opt);
      });
      if (sequenceList.length) {
        await loadSequence();
      }
    }

    async function loadSequence() {
      const selection = getSelection();
      if (!selection) return;
      const examId = examSelect.value;
      if (!examId) return;
      stopPlayback();
      setStatus("Loading sequence...");
      const res = await fetch(`${API_BASE}/replay/sequence`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          results_dir: selection.resultsDir,
          split: selection.split,
          mode: selection.mode,
          examination_id: examId,
          default_step_sec: 10.0
        })
      });
      if (!res.ok) {
        setStatus(`Load failed: ${res.status}`);
        return;
      }
      currentSequence = await res.json();
      validSeries = computeValidSeries(currentSequence);
      vo2Series = computeVo2Series(currentSequence, validSeries);
      triggerInfo = computeTrigger(
        validSeries,
        parseFloat(document.getElementById("threshold-input").value),
        parseInt(document.getElementById("persistence-input").value, 10)
      );
      playbackIndex = 0;
      renderProbChart();
      renderVo2Chart();
      updateSummary();
      setStatus(`Loaded ${examId}`);
    }

    document.getElementById("scan-btn").addEventListener("click", scanDatasets);
    document.getElementById("play-btn").addEventListener("click", startPlayback);
    document.getElementById("pause-btn").addEventListener("click", stopPlayback);
    document.getElementById("step-btn").addEventListener("click", stepPlayback);
    document.getElementById("threshold-input").addEventListener("change", applySettings);
    document.getElementById("persistence-input").addEventListener("change", applySettings);
    datasetSelect.addEventListener("change", loadSequenceList);
    examSelect.addEventListener("change", loadSequence);

    scanDatasets();
  </script>
</body>
</html>
